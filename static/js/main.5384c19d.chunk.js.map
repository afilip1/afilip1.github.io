{"version":3,"sources":["util.ts","hooks/game.ts","hooks/grid.ts","components/controlpanel.tsx","components/cell.tsx","components/board.tsx","components/game.tsx","index.tsx"],"names":["Array","prototype","equals","other","this","length","every","element","index","shuffle","i","j","Math","floor","random","zip","map","e","withIndex","from","entries","countBy","predicate","filter","GameState","range","start","end","v","k","useGame","initSize","initMineCount","useState","gridSize","setGridSize","getNeighbors","useCallback","cellIndex","x","y","useGrid","mineCount","setMineCount","firstClick","setFirstClick","mines","setMines","adjacent","setAdjacent","fill","revealed","setRevealed","flagged","setFlagged","dimmed","setDimmed","populateBoard","firstClickedCell","splice","cell","n","getGameState","emptyCells","isMine","flaggedAllMines","Won","some","isRevealed","Lost","InProgress","handleCellLeftClick","revealCascade","nextRevealed","slice","queue","forEach","center","shift","highlighted","concat","nextDimmed","h","unrevealed","u","push","revealAllMines","neighbors","unflaggedNeighbors","revealUnflaggedNeighbors","nextFlagged","revealCell","flagCell","board","resetBoard","size","handleCellRightClick","event","preventDefault","handleCellMiddleOver","handleMiddleUp","GameStatus","status","gameState","minesLeft","ControlPanel","props","settingsChanged","setSettingsChanged","className","onSubmit","onSettingsUpdate","autoComplete","name","type","value","onChange","currentTarget","Cell","isDimmed","onLeftClick","onRightClick","onMiddleOver","children","onClick","onContextMenu","onMouseEnter","onMouseDown","CellHidden","isFlagged","CellRevealed","adjacentCount","countColors","undefined","style","color","Board","cellIds","rows","rowId","key","cellId","renderCell","Game","useCookies","cookies","setCookie","onMouseUp","button","Boolean","newGridSize","newMineCount","buttons","Root","CookiesProvider","ReactDOM","render","document","getElementById"],"mappings":"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","file":"static/js/main.5384c19d.chunk.js","sourcesContent":["/* eslint no-extend-native: [\"error\", { \"exceptions\": [\"Array\"]}] */\r\ndeclare global {\r\n   interface Array<T> {\r\n      equals(other: T[]): boolean\r\n      shuffle(): T[]\r\n      zip<U>(other: U[]): [T, U][]\r\n      withIndex(): [number, T][]\r\n      countBy(predicate: (value: T) => boolean): number\r\n   }\r\n}\r\n\r\n// unbelievable that I have to write this\r\nArray.prototype.equals = function <T>(this: T[], other: T[]) {\r\n   return (this.length === other.length) && this.every((element, index) => element === other[index]);\r\n}\r\n\r\nArray.prototype.shuffle = function <T>(this: T[]) {\r\n   for (let i = this.length - 1; i > 0; i--) {\r\n      const j = Math.floor(Math.random() * (i + 1));\r\n      [this[i], this[j]] = [this[j], this[i]];\r\n   }\r\n   return this;\r\n}\r\n\r\nArray.prototype.zip = function <T, U>(this: T[], other: U[]) {\r\n   return this.map((e, i) => [e, other[i]]);\r\n}\r\n\r\nArray.prototype.withIndex = function <T>(this: T[]) {\r\n   return Array.from(this.entries());\r\n}\r\n\r\nArray.prototype.countBy = function <T>(this: T[], predicate: (item: T) => boolean) {\r\n   return this.filter(predicate).length;\r\n}\r\n\r\nconst range = function (start: number, end: number) {\r\n   return Array.from({ length: end - start }, (v, k) => k + start);\r\n}\r\n\r\nexport { range };","import { useState, useCallback } from \"react\";\r\nimport { useGrid } from \"src/hooks/grid\"\r\n\r\nexport type BoardState = {\r\n   mines: boolean[],\r\n   revealed: boolean[],\r\n   flagged: boolean[],\r\n   adjacent: (number | null)[],\r\n   dimmed: boolean[],\r\n};\r\n\r\nexport enum GameState {\r\n   InProgress,\r\n   Won,\r\n   Lost,\r\n}\r\n\r\ntype InitBoardParams = {\r\n   initSize: number,\r\n   initMineCount: number,\r\n};\r\n\r\nexport function useGame({ initSize, initMineCount }: InitBoardParams) {\r\n   const { gridSize, setGridSize, getNeighbors } = useGrid(initSize);\r\n\r\n   const [mineCount, setMineCount] = useState(initMineCount);\r\n\r\n   const [firstClick, setFirstClick] = useState<number | null>(null);\r\n\r\n   const [mines, setMines] = useState<boolean[]>([]);\r\n   const [adjacent, setAdjacent] = useState<(number | null)[]>([]);\r\n   const [revealed, setRevealed] = useState(Array(gridSize * gridSize).fill(false));\r\n   const [flagged, setFlagged] = useState(Array(gridSize * gridSize).fill(false));\r\n   const [dimmed, setDimmed] = useState(Array(gridSize * gridSize).fill(false));\r\n\r\n   const resetBoard = (size: number, mineCount: number) => {\r\n      setGridSize(size);\r\n      setMineCount(mineCount);\r\n\r\n      setMines([]);\r\n      setAdjacent([]);\r\n      setRevealed(Array(size * size).fill(false));\r\n      setFlagged(Array(size * size).fill(false));\r\n      setDimmed(Array(size * size).fill(false));\r\n   }\r\n\r\n   const populateBoard = useCallback((firstClickedCell: number) => {\r\n      const mines = Array((gridSize * gridSize) - 1)\r\n         .fill(true, 0, mineCount)\r\n         .fill(false, mineCount)\r\n         .shuffle();\r\n\r\n      mines.splice(firstClickedCell, 0, false); // make sure first clicked cell is never a mine\r\n\r\n      const adjacent = mines.withIndex().map(([cell, mine]) =>\r\n         mine\r\n            ? null\r\n            : getNeighbors(cell).countBy((n) => mines[n])\r\n      );\r\n\r\n      setMines(mines);\r\n      setAdjacent(adjacent);\r\n   }, [gridSize, mineCount, getNeighbors]);\r\n\r\n   const getGameState = useCallback(() => {\r\n      const emptyCells = mines.map(isMine => !isMine);\r\n      const flaggedAllMines = mines.equals(flagged);\r\n\r\n      if (revealed.equals(emptyCells) && flaggedAllMines) {\r\n         return GameState.Won;\r\n      }\r\n\r\n      const mineRevealed = revealed.zip(mines).some(([isRevealed, isMine]) => isRevealed && isMine)\r\n      if (mineRevealed) {\r\n         return GameState.Lost;\r\n      }\r\n\r\n      return GameState.InProgress;\r\n   }, [mines, flagged, revealed]);\r\n\r\n   const handleCellLeftClick = useCallback((cell: number) => {\r\n      if (getGameState() !== GameState.InProgress) return;\r\n\r\n      if (mines.length === 0) {\r\n         populateBoard(cell);\r\n         setFirstClick(cell);\r\n         return;\r\n      }\r\n\r\n      const revealAllMines = (cell: number) => {\r\n         const nextRevealed = revealed\r\n            .zip(mines)\r\n            .map(([isRevealed, isMine]) => isRevealed || isMine);\r\n\r\n         setRevealed(nextRevealed);\r\n\r\n         const highlighted = getNeighbors(cell).concat(cell);\r\n\r\n         let nextDimmed = Array(gridSize * gridSize).fill(true);\r\n         highlighted.forEach(h => nextDimmed[h] = false);\r\n\r\n         setDimmed(nextDimmed);\r\n      }\r\n\r\n      const revealCascade = (...queue: number[]) => {\r\n         let nextRevealed = revealed.slice()\r\n         queue.forEach(cell => nextRevealed[cell] = true);\r\n\r\n         while (queue.length > 0) {\r\n            const center = queue.shift() as number;\r\n\r\n            if (mines[center]) {\r\n               nextRevealed[center] = true;\r\n\r\n               const highlighted = getNeighbors(center).concat(center);\r\n\r\n               let nextDimmed = Array(gridSize * gridSize).fill(true);\r\n               highlighted.forEach(h => nextDimmed[h] = false);\r\n\r\n               setDimmed(nextDimmed);\r\n            }\r\n\r\n            if (adjacent[center] === 0) {\r\n               const unrevealed = getNeighbors(center).filter(n => !nextRevealed[n]);\r\n               unrevealed.forEach(u => nextRevealed[u] = true);\r\n               queue.push(...unrevealed);\r\n            }\r\n         }\r\n\r\n         return nextRevealed;\r\n      }\r\n\r\n      const revealUnflaggedNeighbors = (cell: number) => {\r\n         const neighbors = getNeighbors(cell);\r\n\r\n         const adjacentFlags = neighbors.filter(n => flagged[n])\r\n         if (adjacentFlags.length !== adjacent[cell]) return;\r\n\r\n         const unflaggedNeighbors = neighbors.filter(n => !(revealed[n] || flagged[n]));\r\n\r\n         setRevealed(revealCascade(...unflaggedNeighbors));\r\n      }\r\n\r\n      const revealCell = (cell: number) => {\r\n         const nextRevealed = revealCascade(cell);\r\n         const nextFlagged = flagged.slice();\r\n\r\n         nextFlagged[cell] = false;\r\n\r\n         setRevealed(nextRevealed);\r\n         setFlagged(nextFlagged);\r\n      }\r\n\r\n      if (flagged[cell]) return;\r\n\r\n      if (mines[cell]) {\r\n         revealAllMines(cell);\r\n      } else if (revealed[cell]) {\r\n         revealUnflaggedNeighbors(cell);\r\n      } else {\r\n         revealCell(cell);\r\n      }\r\n   }, [mines, revealed, flagged, adjacent, getGameState, getNeighbors, populateBoard]);\r\n\r\n   if (firstClick) {\r\n      handleCellLeftClick(firstClick);\r\n      setFirstClick(null);\r\n   }\r\n\r\n   const flagCell = (cell: number) => {\r\n      let nextFlagged = flagged.slice();\r\n      nextFlagged[cell] = !nextFlagged[cell];\r\n      setFlagged(nextFlagged);\r\n   }\r\n\r\n   const handleCellRightClick = (event: React.MouseEvent, cell: number) => {\r\n      event.preventDefault();\r\n      if (getGameState() !== GameState.InProgress) return;\r\n\r\n      flagCell(cell);\r\n   };\r\n\r\n   const handleCellMiddleOver = (cell: number) => {\r\n      const highlighted = getNeighbors(cell).concat(cell);\r\n\r\n      let nextDimmed = Array(gridSize * gridSize).fill(true);\r\n      highlighted.forEach(h => nextDimmed[h] = false);\r\n\r\n      setDimmed(nextDimmed);\r\n   }\r\n\r\n   const handleMiddleUp = () => {\r\n      setDimmed(Array(gridSize * gridSize).fill(false));\r\n   }\r\n\r\n   return {\r\n      gridSize,\r\n      mineCount,\r\n      setMineCount,\r\n      board: { mines, revealed, flagged, adjacent, dimmed },\r\n      resetBoard,\r\n      handleCellLeftClick,\r\n      handleCellRightClick,\r\n      handleCellMiddleOver,\r\n      handleMiddleUp,\r\n      flagCell,\r\n      getGameState,\r\n   };\r\n}\r\n","import { useCallback, useState } from \"react\";\r\n\r\nexport function useGrid(initSize: number) {\r\n   const [gridSize, setGridSize] = useState(initSize);\r\n\r\n   const getNeighbors: (cellIndex: number) => number[] =\r\n      useCallback((cellIndex) => {\r\n         const indexToCoords: (index: number) => [number, number] =\r\n            index => [index % gridSize, Math.floor(index / gridSize)];\r\n\r\n         const coordsToIndex: ([x, y]: [number, number]) => number =\r\n            ([x, y]) => y * gridSize + x;\r\n\r\n         const isInBounds = ([x, y]: [number, number]) =>\r\n            x >= 0 && x < gridSize && y >= 0 && y < gridSize;\r\n\r\n         const [x, y] = indexToCoords(cellIndex);\r\n         const neighbors: [number, number][] = [\r\n            [x - 1, y - 1], [x, y - 1], [x + 1, y - 1],\r\n            [x - 1, y], /* ~center point~ */[x + 1, y],\r\n            [x - 1, y + 1], [x, y + 1], [x + 1, y + 1],\r\n         ];\r\n\r\n         return neighbors\r\n            .filter(isInBounds)\r\n            .map(coordsToIndex);\r\n      }, [gridSize]);\r\n\r\n   return {\r\n      gridSize,\r\n      setGridSize,\r\n      getNeighbors\r\n   };\r\n}","import React, { useState, FormEvent } from \"react\";\r\nimport { GameState } from \"src/hooks/game\"\r\n\r\ntype GameStatusProps = {\r\n   gameState: GameState,\r\n   minesLeft: number,\r\n}\r\n\r\nfunction GameStatus({ gameState, minesLeft }: GameStatusProps) {\r\n   let status;\r\n   switch (gameState) {\r\n      case GameState.InProgress:\r\n         status = \"Flags left: \" + minesLeft;\r\n         break;\r\n      case GameState.Won:\r\n         status = \"You won!\"\r\n         break;\r\n      case GameState.Lost:\r\n         status = \"You lost :(\"\r\n         break;\r\n   }\r\n\r\n   return <h2>{status}</h2>;\r\n}\r\n\r\ntype ControlPanelProps = {\r\n   gridSize: number,\r\n   mineCount: number,\r\n   onSettingsUpdate: (gridSize: number, mineCount: number) => void\r\n} & GameStatusProps;\r\n\r\nexport function ControlPanel(props: ControlPanelProps) {\r\n   const [gridSize, setGridSize] = useState(props.gridSize);\r\n   const [mineCount, setMineCount] = useState(props.mineCount);\r\n   const [settingsChanged, setSettingsChanged] = useState(false);\r\n\r\n   const handleGridSizeChange = (event: FormEvent<HTMLInputElement>) => {\r\n      setGridSize(+event.currentTarget.value);\r\n      setSettingsChanged(true);\r\n   };\r\n\r\n   const handleMineCountChange = (event: FormEvent<HTMLInputElement>) => {\r\n      setMineCount(+event.currentTarget.value);\r\n      setSettingsChanged(true);\r\n   }\r\n\r\n   const handleSubmit = (event: FormEvent<HTMLFormElement>) => {\r\n      event.preventDefault();\r\n      props.onSettingsUpdate(gridSize, mineCount);\r\n      setSettingsChanged(false);\r\n   }\r\n\r\n   return (\r\n      <div className=\"control-panel\">\r\n         <h1>MINEKONG</h1>\r\n\r\n         <GameStatus gameState={props.gameState} minesLeft={props.minesLeft} />\r\n\r\n         <form onSubmit={handleSubmit} autoComplete=\"off\">\r\n            <label>\r\n               Grid size\r\n               <input name=\"gridSize\" type=\"text\" value={gridSize} onChange={handleGridSizeChange} />\r\n            </label>\r\n\r\n            <label>\r\n               Mine count\r\n               <input name=\"mineCount\" type=\"text\" value={mineCount} onChange={handleMineCountChange} />\r\n            </label>\r\n            <button type=\"submit\">{settingsChanged ? \"Apply and restart\" : \"Restart\"}</button>\r\n         </form>\r\n\r\n         <div className=\"rules\">\r\n            <div>\r\n               <h2>Rules</h2>\r\n               <p>A board contains a number of cells. Each cell can be either empty or a mine.</p>\r\n               <p>The goal of the game is to flag all the mines and reveal all the empty cells.</p>\r\n               <p>If you reveal a mine, it's game over!</p>\r\n               <p>Empty cells show a number of mines that reside in the 8 adjacent cells.</p>\r\n            </div>\r\n\r\n            <div>\r\n               <h2>Controls</h2>\r\n               <p><strong>Left click</strong> on an unrevealed cell to reveal it.</p>\r\n               <p><strong>Right click</strong> on an unrevealed cell to flag it as a mine.</p>\r\n               <p><strong>Hold middle mouse button</strong> over an revealed cell to highlight its neighbors.</p>\r\n\r\n               <p><strong>Tip #1:</strong> If you've placed enough flags near a revealed cell, you can left click on it to automatically reveal cells without flags.</p>\r\n               <p><strong>Tip #2:</strong> The first cell you click will never be a mine, so don't worry about where to click.</p>\r\n            </div>\r\n         </div>\r\n      </div>\r\n   );\r\n}","import React, { ReactNode } from \"react\";\r\n\r\ntype CellProps = {\r\n   isRevealed: boolean,\r\n   isDimmed: boolean,\r\n   onLeftClick: () => void\r\n   onRightClick: (e: React.MouseEvent) => void\r\n   onMiddleOver: (e: React.MouseEvent) => void\r\n   children: ReactNode\r\n};\r\n\r\nfunction Cell({ isRevealed, isDimmed, onLeftClick, onRightClick, onMiddleOver, children }: CellProps) {\r\n   let className = \"cell cell-active\";\r\n   if (isRevealed) className += \" cell-revealed\";\r\n   if (isDimmed) className += \" cell-dimmed\";\r\n\r\n   return (\r\n      <button\r\n         className={className}\r\n         onClick={onLeftClick}\r\n         onContextMenu={onRightClick}\r\n         onMouseEnter={onMiddleOver}\r\n         onMouseDown={onMiddleOver}\r\n      >\r\n         {children}\r\n      </button>\r\n   );\r\n}\r\n\r\ntype CellHiddenProps = {\r\n   isFlagged: boolean,\r\n   isDimmed: boolean,\r\n   onLeftClick: () => void,\r\n   onRightClick: (e: React.MouseEvent) => void,\r\n};\r\n\r\nfunction CellHidden({ isFlagged, isDimmed, onLeftClick, onRightClick }: CellHiddenProps) {\r\n   return (\r\n      <Cell\r\n         isRevealed={false}\r\n         isDimmed={isDimmed}\r\n         onLeftClick={onLeftClick}\r\n         onRightClick={onRightClick}\r\n         onMiddleOver={() => { }}\r\n      >\r\n         {isFlagged && \"🚩\"}\r\n      </Cell>\r\n   );\r\n}\r\n\r\ntype CellRevealedProps = {\r\n   isMine: boolean,\r\n   isDimmed: boolean,\r\n   adjacentCount: number | null,\r\n   onLeftClick: () => void,\r\n   onMiddleOver: (e: React.MouseEvent) => void,\r\n};\r\n\r\nfunction CellRevealed({ isMine, isDimmed, adjacentCount, onLeftClick, onMiddleOver }: CellRevealedProps) {\r\n   const countColors = [undefined, \"blue\", \"green\", \"red\", \"purple\", \"maroon\", \"turquoise\", \"black\", \"gray\"];\r\n\r\n   return (\r\n      <Cell\r\n         isRevealed={true}\r\n         isDimmed={isDimmed}\r\n         onLeftClick={onLeftClick}\r\n         onRightClick={(e) => e.preventDefault()}\r\n         onMiddleOver={onMiddleOver}\r\n      >\r\n         {isMine && \"💣\"}\r\n         {adjacentCount !== null && adjacentCount > 0 &&\r\n            <span style={{ color: countColors[adjacentCount] }}>{adjacentCount}</span>\r\n         }\r\n      </Cell>\r\n   );\r\n};\r\n\r\nexport { CellHidden, CellRevealed };","import React from \"react\";\r\nimport { CellHidden, CellRevealed } from \"src/components/cell\";\r\nimport { range } from \"src/util\";\r\nimport { BoardState } from \"src/hooks/game\";\r\n\r\ntype RenderCellProps = {\r\n   board: BoardState\r\n   onLeftClick: (i: number) => void\r\n   onRightClick: (e: React.MouseEvent, i: number) => void\r\n   onMiddleOver: (e: React.MouseEvent, i: number) => void\r\n}\r\n\r\nfunction renderCell(props: RenderCellProps, cellId: number) {\r\n   const {\r\n      board: { mines, flagged, revealed, adjacent, dimmed },\r\n      onLeftClick, onRightClick, onMiddleOver\r\n   } = props;\r\n\r\n   if (revealed[cellId]) {\r\n      return (\r\n         <CellRevealed\r\n            key={cellId}\r\n            isMine={mines[cellId]}\r\n            isDimmed={dimmed[cellId]}\r\n            onLeftClick={() => onLeftClick(cellId)}\r\n            onMiddleOver={(e) => onMiddleOver(e, cellId)}\r\n            adjacentCount={adjacent[cellId]}\r\n         />\r\n      );\r\n   } else {\r\n      return (\r\n         <CellHidden\r\n            key={cellId}\r\n            isDimmed={dimmed[cellId]}\r\n            isFlagged={flagged[cellId]}\r\n            onLeftClick={() => onLeftClick(cellId)}\r\n            onRightClick={(e) => onRightClick(e, cellId)}\r\n         />\r\n      );\r\n   }\r\n}\r\n\r\ntype BoardProps = { size: number } & RenderCellProps;\r\n\r\nexport function Board({ size, ...props }: BoardProps) {\r\n   let cellIds = range(0, size * size);\r\n   let rowIds = range(0, size);\r\n\r\n   let rows = rowIds.map(rowId =>\r\n      <div className=\"board-row\" key={rowId}>\r\n         {\r\n            cellIds\r\n               .slice(rowId * size, (rowId + 1) * size) // get cells in the row\r\n               .map(cellId => renderCell(props, cellId))\r\n         }\r\n      </div>\r\n   );\r\n\r\n   return <div className=\"board\">{rows}</div>;\r\n}","import React from \"react\";\r\nimport { useCookies } from \"react-cookie\";\r\nimport \"src/util\"\r\nimport { ControlPanel } from \"src/components/controlpanel\";\r\nimport { Board } from \"src/components/board\";\r\nimport { useGame } from \"src/hooks/game\"\r\n\r\nexport function Game() {\r\n   const [cookies, setCookie] = useCookies([\"minekong\"]);\r\n\r\n   const initSize = cookies.size ?? 9;\r\n   const initMineCount = cookies.mineCount ?? 10;\r\n\r\n   const {\r\n      gridSize,\r\n      mineCount,\r\n      board,\r\n      resetBoard,\r\n      handleCellLeftClick,\r\n      handleCellRightClick,\r\n      handleCellMiddleOver,\r\n      handleMiddleUp,\r\n      getGameState,\r\n   } = useGame({ initSize, initMineCount });\r\n\r\n   const handleSettingsUpdate = (newGridSize: number, newMineCount: number) => {\r\n      setCookie('size', newGridSize);\r\n      setCookie('mineCount', newMineCount);\r\n      resetBoard(newGridSize, newMineCount);\r\n   }\r\n\r\n   const handleMouseUp = (e: React.MouseEvent) => {\r\n      if (e.button === 1) {\r\n         handleMiddleUp();\r\n      }\r\n   }\r\n\r\n   const handleMiddleOver = (e: React.MouseEvent, i: number) => {\r\n      if (e.buttons === 4) {\r\n         handleCellMiddleOver(i);\r\n      }\r\n   }\r\n\r\n   return (\r\n      <div className=\"game\" onContextMenu={(e) => e.preventDefault()} onMouseUp={handleMouseUp}>\r\n         <ControlPanel\r\n            gridSize={gridSize}\r\n            mineCount={mineCount}\r\n            gameState={getGameState()}\r\n            minesLeft={mineCount - board.flagged.countBy(Boolean)}\r\n            onSettingsUpdate={handleSettingsUpdate}\r\n         />\r\n\r\n         <Board\r\n            size={gridSize}\r\n            board={board}\r\n            onLeftClick={handleCellLeftClick}\r\n            onRightClick={handleCellRightClick}\r\n            onMiddleOver={handleMiddleOver}\r\n         />\r\n      </div>\r\n   );\r\n}","import React from \"react\";\r\nimport ReactDOM from \"react-dom\";\r\nimport \"src/index.css\";\r\n\r\nimport { CookiesProvider } from 'react-cookie';\r\n\r\nimport { Game } from \"src/components/game\";\r\n\r\nfunction Root() {\r\n   return (\r\n      <CookiesProvider>\r\n         <Game />\r\n      </CookiesProvider>\r\n   );\r\n}\r\n\r\nReactDOM.render(\r\n   <Root />,\r\n   document.getElementById(\"root\")\r\n)"],"sourceRoot":""}